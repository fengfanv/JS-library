<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>canvas3dTo2d</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        
        body {
            width: 100%;
            height: 100%;
            background-color: antiquewhite;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            background-color: white;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        //1、初始化页面环境
        let screenWidth = document.documentElement.clientWidth; //屏幕的宽
        let screenHeight = document.documentElement.clientHeight; //屏幕的高

        let containerWidth = 0; //容器宽
        let containerHeight = 0; //容器高

        //兼容显示器，让游戏已9比16的矩形显示
        if (screenWidth > 768) {
            containerWidth = 9 / 16 * screenHeight; // newWidth/newHeight=9/16
            containerHeight = screenHeight;
        } else {
            containerWidth = screenWidth;
            containerHeight = screenHeight;
        }

        //2、初始化canvas环境
        let canvas = document.getElementById("canvas");
        canvas.width = containerWidth;
        canvas.height = containerHeight;
        let ctx = canvas.getContext('2d'); //生成一个canvas的实例



        //想象一个正方体（下面坐标系，已经转成，canvas坐标系，canvas坐标系，x和y轴起点在左上角）
        let cube = [
            [-50, 50, 50], //前面，左上角，x,y,z
            [50, 50, 50], //前面，右上角
            [-50, -50, 50], //前面，左下角
            [50, -50, 50], //前面，右下角
            [-50, 50, -50], //后面，左上角
            [50, 50, -50], //后面，右上角
            [-50, -50, -50], //后面，左下角
            [50, -50, -50], //后面，右下角
        ]

        let viewPoint = [0, 0, 300]; //观察点，注意，这个观察点在canvas的中间，看左上上角正方体时，所看见的不是正面，是正方体的右下角


        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText('观察点', viewPoint[0], viewPoint[1]);

        //把3d模型渲染到2d平面上
        function render3dTo2d(x, y, z) {
            let newX = 0;
            let newY = 0;

            //算，点投影到xy平面上后，点在y轴的位置
            //newY/y=(viewPoint[2]-z)/viewPoint[2]   //这个为什么这样写，看文档就明白了。观察点与点和这个点的投影形成了两个相似三角形，所以算点的投影点位置时，可以用矩形和三角形相似原理，算点位置
            //newY/(y-viewPoint[1])=(viewPoint[2]-z)/viewPoint[2]
            newY = (viewPoint[2] - z) / viewPoint[2] * (y - viewPoint[1]) + (containerHeight / 2);

            //算，点投影到xy平面上后，点在x轴的位置
            //newX/x=(viewPoint[2]-z)/viewPoint[2]
            //newX/(x-viewPoint[0])=(viewPoint[2]-z)/viewPoint[2]
            newX = (viewPoint[2] - z) / viewPoint[2] * (x - viewPoint[0]) + (containerWidth / 2);



            return {
                x: newX,
                y: newY
            }
        }

        function draw() {

            ctx.clearRect(0, 0, 1920, 1920)

            let afterCube = [];
            for (let i = 0; i < cube.length; i++) {
                let x = cube[i][0];
                let y = cube[i][1];
                let z = cube[i][2];

                let point = render3dTo2d(x, y, z);

                // let point = {
                //     x,
                //     y,
                //     z
                // }

                ctx.font = "12px Arial";
                ctx.fillText(i, point.x, point.y);

                afterCube.push(point);

                //画线
                if (i == 1) {
                    renderLine(afterCube[0], afterCube[1])
                }

                if (i == 2) {
                    renderLine(afterCube[0], afterCube[2])
                }

                if (i == 3) {
                    renderLine(afterCube[2], afterCube[3])
                    renderLine(afterCube[1], afterCube[3])
                }

                //
                if (i == 4) {
                    renderLine(afterCube[0], afterCube[4])
                }

                if (i == 5) {
                    renderLine(afterCube[4], afterCube[5])
                    renderLine(afterCube[1], afterCube[5])
                }

                if (i == 6) {
                    renderLine(afterCube[4], afterCube[6])
                    renderLine(afterCube[6], afterCube[2])
                }

                if (i == 7) {
                    renderLine(afterCube[7], afterCube[3])
                    renderLine(afterCube[7], afterCube[5])
                    renderLine(afterCube[7], afterCube[6])
                }

            }

        }

        function renderLine(start, end) {
            ctx.beginPath()
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.closePath();
            ctx.stroke();
        }

        //旋转
        function animationFrame() {

            let rotationAngle = 1;
            setInterval(() => {

                for (let key in cube) {
                    let point = cube[key]
                        // 保存x,y,z坐标
                    let x = point[0]
                    let y = point[1]
                    let z = point[2]
                        // 变换后的x坐标
                    point[0] = x * Math.cos(rotationAngle / 180 * Math.PI) - z * Math.sin(rotationAngle / 180 * Math.PI)
                        // 绕y轴旋转，y左边不会发生变化
                    point[1] = y
                        // 变换后的z坐标
                    point[2] = z * Math.cos(rotationAngle / 180 * Math.PI) + x * Math.sin(rotationAngle / 180 * Math.PI)
                }
                draw(); //渲染方块
            }, 100)
        }


        animationFrame();
    </script>
</body>

</html>